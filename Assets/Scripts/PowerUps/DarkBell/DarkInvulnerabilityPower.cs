using UnityEngine;
using System.Collections;

public class DarkInvulnerabilityPower : MonoBehaviour
{
    [Header("Configuración")]
    public float activationHealthThreshold = 1f; // Medio corazón
    public float invulnerabilityDuration = 20f;
    public GameObject darknessProjectilePrefab;
    public int numberOfProjectiles = 5;
    public float projectileSpawnDistance = 3f;
    public float recoveryTransitionTime = 3f;
    public float healAmountPerOrb = 0.5f;

    private PlayerHealth playerHealth;
    private PlayerController playerController;
    private SpriteRenderer playerSpriteRenderer;
    private Color originalColor;
    private bool isActive = false;
    private bool powerActive = false;
    private bool hasBeenActivated = false;
    private bool isRecovering = false;

    private void Awake()
    {
        playerHealth = GetComponent<PlayerHealth>();
        playerController = GetComponent<PlayerController>();
        playerSpriteRenderer = GetComponent<SpriteRenderer>();

        if (playerSpriteRenderer != null)
        {
            originalColor = playerSpriteRenderer.color;
        }

        Debug.Log("[DARK INVULNERABILITY] Sistema inicializado");
    }

    private void Update()
    {
        if (!powerActive || isActive || hasBeenActivated) return;

        // Verificar si se debe activar la invulnerabilidad (activar si está en o por debajo del umbral)
        if (playerHealth != null && playerHealth.currentHealth <= activationHealthThreshold)
        {
            StartCoroutine(ActivateDarkInvulnerability());
        }
    }

    private IEnumerator ActivateDarkInvulnerability()
    {
        if (isActive || hasBeenActivated) yield break;

        hasBeenActivated = true;
        isActive = true;
        isRecovering = false;
        Debug.Log("[DARK INVULNERABILITY] Activada!");

        // Activar invulnerabilidad
        if (playerController != null)
        {
            playerController.isInvulnerable = true;
        }

        // Cambiar sprite a negro
        if (playerSpriteRenderer != null)
        {
            playerSpriteRenderer.color = Color.black;
        }

        // Esperar la duración de la invulnerabilidad
        yield return new WaitForSeconds(invulnerabilityDuration);

        // Desactivar invulnerabilidad
        if (playerController != null)
        {
            playerController.isInvulnerable = false;
        }

        // Marcar que estamos en recuperación
        isRecovering = true;

        // Transición de recuperación del color
        if (playerSpriteRenderer != null)
        {
            yield return StartCoroutine(RecoverPlayerColor());
        }

        isRecovering = false;

        // Crear proyectiles de oscuridad (después de que el color haya vuelto a la normalidad)
        CreateDarknessProjectiles();

        isActive = false;
        Debug.Log("[DARK INVULNERABILITY] Finalizada");
    }

    private IEnumerator RecoverPlayerColor()
    {
        if (playerSpriteRenderer == null) yield break;

        Color blackColor = Color.black;
        float elapsedTime = 0f;

        while (elapsedTime < recoveryTransitionTime)
        {
            elapsedTime += Time.deltaTime;
            float t = elapsedTime / recoveryTransitionTime;
            playerSpriteRenderer.color = Color.Lerp(blackColor, originalColor, t);
            yield return null;
        }

        playerSpriteRenderer.color = originalColor;
        Debug.Log("[DARK INVULNERABILITY] Color recuperado");
    }

    private void CreateDarknessProjectiles()
    {
        if (darknessProjectilePrefab == null) return;

        for (int i = 0; i < numberOfProjectiles; i++)
        {
            float angle = (360f / numberOfProjectiles) * i;
            Vector2 direction = new Vector2(
                Mathf.Cos(angle * Mathf.Deg2Rad),
                Mathf.Sin(angle * Mathf.Deg2Rad)
            );

            Vector2 spawnPosition = (Vector2)transform.position + (direction * projectileSpawnDistance);
            GameObject projectile = Instantiate(darknessProjectilePrefab, spawnPosition, Quaternion.identity);

            // Configurar el proyectil con el heal amount
            DarknessProjectile darknessProjectile = projectile.GetComponent<DarknessProjectile>();
            if (darknessProjectile != null)
            {
                darknessProjectile.healAmount = healAmountPerOrb;
            }

            // Rotar el proyectil para que mire hacia el jugador
            Vector2 lookDirection = (Vector2)transform.position - spawnPosition;
            float angleRotation = Mathf.Atan2(lookDirection.y, lookDirection.x) * Mathf.Rad2Deg;
            projectile.transform.rotation = Quaternion.Euler(0, 0, angleRotation);
        }

        Debug.Log($"[DARK INVULNERABILITY] {numberOfProjectiles} proyectiles de oscuridad creados");
    }

    public void ActivatePower()
    {
        powerActive = true;
        hasBeenActivated = false;
        Debug.Log("[DARK INVULNERABILITY] Power activado");
    }

    public void DeactivatePower()
    {
        powerActive = false;
        hasBeenActivated = true;

        // Detener cualquier coroutine activa
        StopAllCoroutines();

        // Restaurar color original
        if (playerSpriteRenderer != null)
        {
            playerSpriteRenderer.color = originalColor;
        }

        // Desactivar invulnerabilidad
        if (playerController != null)
        {
            playerController.isInvulnerable = false;
        }

        isActive = false;
        isRecovering = false;
        Debug.Log("[DARK INVULNERABILITY] Power desactivado");
    }

    // Método para resetear si es necesario
    public void ResetActivation()
    {
        hasBeenActivated = false;
        Debug.Log("[DARK INVULNERABILITY] Reset de activación");
    }

    // Método para verificar si se puede recibir daño
    public bool IsProtected()
    {
        return isActive || isRecovering;
    }

    private void OnDisable()
    {
        DeactivatePower();
    }
}